var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

(function(global) {
  /**
   * Polyfill URLSearchParams
   *
   * Inspired from : https://github.com/WebReflection/url-search-params/blob/master/src/url-search-params.js
   */

  var checkIfIteratorIsSupported = function() {
    try {
      return !!Symbol.iterator;
    } catch (error) {
      return false;
    }
  };


  var iteratorSupported = checkIfIteratorIsSupported();

  var createIterator = function(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return { done: value === void 0, value: value };
      }
    };

    if (iteratorSupported) {
      iterator[Symbol.iterator] = function() {
        return iterator;
      };
    }

    return iterator;
  };

  /**
   * Search param name and values should be encoded according to https://url.spec.whatwg.org/#urlencoded-serializing
   * encodeURIComponent() produces the same result except encoding spaces as `%20` instead of `+`.
   */
  var serializeParam = function(value) {
    return encodeURIComponent(value).replace(/%20/g, '+');
  };

  var deserializeParam = function(value) {
    return decodeURIComponent(String(value).replace(/\+/g, ' '));
  };

  var polyfillURLSearchParams = function() {

    var URLSearchParams = function(searchString) {
      Object.defineProperty(this, '_entries', { writable: true, value: {} });
      var typeofSearchString = typeof searchString;

      if (typeofSearchString === 'undefined') ; else if (typeofSearchString === 'string') {
        if (searchString !== '') {
          this._fromString(searchString);
        }
      } else if (searchString instanceof URLSearchParams) {
        var _this = this;
        searchString.forEach(function(value, name) {
          _this.append(name, value);
        });
      } else if ((searchString !== null) && (typeofSearchString === 'object')) {
        if (Object.prototype.toString.call(searchString) === '[object Array]') {
          for (var i = 0; i < searchString.length; i++) {
            var entry = searchString[i];
            if ((Object.prototype.toString.call(entry) === '[object Array]') || (entry.length !== 2)) {
              this.append(entry[0], entry[1]);
            } else {
              throw new TypeError('Expected [string, any] as entry at index ' + i + ' of URLSearchParams\'s input');
            }
          }
        } else {
          for (var key in searchString) {
            if (searchString.hasOwnProperty(key)) {
              this.append(key, searchString[key]);
            }
          }
        }
      } else {
        throw new TypeError('Unsupported input\'s type for URLSearchParams');
      }
    };

    var proto = URLSearchParams.prototype;

    proto.append = function(name, value) {
      if (name in this._entries) {
        this._entries[name].push(String(value));
      } else {
        this._entries[name] = [String(value)];
      }
    };

    proto.delete = function(name) {
      delete this._entries[name];
    };

    proto.get = function(name) {
      return (name in this._entries) ? this._entries[name][0] : null;
    };

    proto.getAll = function(name) {
      return (name in this._entries) ? this._entries[name].slice(0) : [];
    };

    proto.has = function(name) {
      return (name in this._entries);
    };

    proto.set = function(name, value) {
      this._entries[name] = [String(value)];
    };

    proto.forEach = function(callback, thisArg) {
      var entries;
      for (var name in this._entries) {
        if (this._entries.hasOwnProperty(name)) {
          entries = this._entries[name];
          for (var i = 0; i < entries.length; i++) {
            callback.call(thisArg, entries[i], name, this);
          }
        }
      }
    };

    proto.keys = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push(name);
      });
      return createIterator(items);
    };

    proto.values = function() {
      var items = [];
      this.forEach(function(value) {
        items.push(value);
      });
      return createIterator(items);
    };

    proto.entries = function() {
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
      });
      return createIterator(items);
    };

    if (iteratorSupported) {
      proto[Symbol.iterator] = proto.entries;
    }

    proto.toString = function() {
      var searchArray = [];
      this.forEach(function(value, name) {
        searchArray.push(serializeParam(name) + '=' + serializeParam(value));
      });
      return searchArray.join('&');
    };


    global.URLSearchParams = URLSearchParams;
  };

  var checkIfURLSearchParamsSupported = function() {
    try {
      var URLSearchParams = global.URLSearchParams;

      return (new URLSearchParams('?a=1').toString() === 'a=1') && (typeof URLSearchParams.prototype.set === 'function');
    } catch (e) {
      return false;
    }
  };

  if (!checkIfURLSearchParamsSupported()) {
    polyfillURLSearchParams();
  }

  var proto = global.URLSearchParams.prototype;

  if (typeof proto.sort !== 'function') {
    proto.sort = function() {
      var _this = this;
      var items = [];
      this.forEach(function(value, name) {
        items.push([name, value]);
        if (!_this._entries) {
          _this.delete(name);
        }
      });
      items.sort(function(a, b) {
        if (a[0] < b[0]) {
          return -1;
        } else if (a[0] > b[0]) {
          return +1;
        } else {
          return 0;
        }
      });
      if (_this._entries) { // force reset because IE keeps keys index
        _this._entries = {};
      }
      for (var i = 0; i < items.length; i++) {
        this.append(items[i][0], items[i][1]);
      }
    };
  }

  if (typeof proto._fromString !== 'function') {
    Object.defineProperty(proto, '_fromString', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: function(searchString) {
        if (this._entries) {
          this._entries = {};
        } else {
          var keys = [];
          this.forEach(function(value, name) {
            keys.push(name);
          });
          for (var i = 0; i < keys.length; i++) {
            this.delete(keys[i]);
          }
        }

        searchString = searchString.replace(/^\?/, '');
        var attributes = searchString.split('&');
        var attribute;
        for (var i = 0; i < attributes.length; i++) {
          attribute = attributes[i].split('=');
          this.append(
            deserializeParam(attribute[0]),
            (attribute.length > 1) ? deserializeParam(attribute[1]) : ''
          );
        }
      }
    });
  }

  // HTMLAnchorElement

})(
  (typeof commonjsGlobal !== 'undefined') ? commonjsGlobal
    : ((typeof window !== 'undefined') ? window
    : ((typeof self !== 'undefined') ? self : commonjsGlobal))
);

(function(global) {
  /**
   * Polyfill URL
   *
   * Inspired from : https://github.com/arv/DOM-URL-Polyfill/blob/master/src/url.js
   */

  var checkIfURLIsSupported = function() {
    try {
      var u = new global.URL('b', 'http://a');
      u.pathname = 'c%20d';
      return (u.href === 'http://a/c%20d') && u.searchParams;
    } catch (e) {
      return false;
    }
  };


  var polyfillURL = function() {
    var _URL = global.URL;

    var URL = function(url, base) {
      if (typeof url !== 'string') url = String(url);

      // Only create another document if the base is different from current location.
      var doc = document, baseElement;
      if (base && (global.location === void 0 || base !== global.location.href)) {
        doc = document.implementation.createHTMLDocument('');
        baseElement = doc.createElement('base');
        baseElement.href = base;
        doc.head.appendChild(baseElement);
        try {
          if (baseElement.href.indexOf(base) !== 0) throw new Error(baseElement.href);
        } catch (err) {
          throw new Error('URL unable to set base ' + base + ' due to ' + err);
        }
      }

      var anchorElement = doc.createElement('a');
      anchorElement.href = url;
      if (baseElement) {
        doc.body.appendChild(anchorElement);
        anchorElement.href = anchorElement.href; // force href to refresh
      }

      if (anchorElement.protocol === ':' || !/:/.test(anchorElement.href)) {
        throw new TypeError('Invalid URL');
      }

      Object.defineProperty(this, '_anchorElement', {
        value: anchorElement
      });


      // create a linked searchParams which reflect its changes on URL
      var searchParams = new global.URLSearchParams(this.search);
      var enableSearchUpdate = true;
      var enableSearchParamsUpdate = true;
      var _this = this;
      ['append', 'delete', 'set'].forEach(function(methodName) {
        var method = searchParams[methodName];
        searchParams[methodName] = function() {
          method.apply(searchParams, arguments);
          if (enableSearchUpdate) {
            enableSearchParamsUpdate = false;
            _this.search = searchParams.toString();
            enableSearchParamsUpdate = true;
          }
        };
      });

      Object.defineProperty(this, 'searchParams', {
        value: searchParams,
        enumerable: true
      });

      var search = void 0;
      Object.defineProperty(this, '_updateSearchParams', {
        enumerable: false,
        configurable: false,
        writable: false,
        value: function() {
          if (this.search !== search) {
            search = this.search;
            if (enableSearchParamsUpdate) {
              enableSearchUpdate = false;
              this.searchParams._fromString(this.search);
              enableSearchUpdate = true;
            }
          }
        }
      });
    };

    var proto = URL.prototype;

    var linkURLWithAnchorAttribute = function(attributeName) {
      Object.defineProperty(proto, attributeName, {
        get: function() {
          return this._anchorElement[attributeName];
        },
        set: function(value) {
          this._anchorElement[attributeName] = value;
        },
        enumerable: true
      });
    };

    ['hash', 'host', 'hostname', 'port', 'protocol']
      .forEach(function(attributeName) {
        linkURLWithAnchorAttribute(attributeName);
      });

    Object.defineProperty(proto, 'search', {
      get: function() {
        return this._anchorElement['search'];
      },
      set: function(value) {
        this._anchorElement['search'] = value;
        this._updateSearchParams();
      },
      enumerable: true
    });

    Object.defineProperties(proto, {

      'toString': {
        get: function() {
          var _this = this;
          return function() {
            return _this.href;
          };
        }
      },

      'href': {
        get: function() {
          return this._anchorElement.href.replace(/\?$/, '');
        },
        set: function(value) {
          this._anchorElement.href = value;
          this._updateSearchParams();
        },
        enumerable: true
      },

      'pathname': {
        get: function() {
          return this._anchorElement.pathname.replace(/(^\/?)/, '/');
        },
        set: function(value) {
          this._anchorElement.pathname = value;
        },
        enumerable: true
      },

      'origin': {
        get: function() {
          // get expected port from protocol
          var expectedPort = { 'http:': 80, 'https:': 443, 'ftp:': 21 }[this._anchorElement.protocol];
          // add port to origin if, expected port is different than actual port
          // and it is not empty f.e http://foo:8080
          // 8080 != 80 && 8080 != ''
          var addPortToOrigin = this._anchorElement.port != expectedPort &&
            this._anchorElement.port !== '';

          return this._anchorElement.protocol +
            '//' +
            this._anchorElement.hostname +
            (addPortToOrigin ? (':' + this._anchorElement.port) : '');
        },
        enumerable: true
      },

      'password': { // TODO
        get: function() {
          return '';
        },
        set: function(value) {
        },
        enumerable: true
      },

      'username': { // TODO
        get: function() {
          return '';
        },
        set: function(value) {
        },
        enumerable: true
      },
    });

    URL.createObjectURL = function(blob) {
      return _URL.createObjectURL.apply(_URL, arguments);
    };

    URL.revokeObjectURL = function(url) {
      return _URL.revokeObjectURL.apply(_URL, arguments);
    };

    global.URL = URL;

  };

  if (!checkIfURLIsSupported()) {
    polyfillURL();
  }

  if ((global.location !== void 0) && !('origin' in global.location)) {
    var getOrigin = function() {
      return global.location.protocol + '//' + global.location.hostname + (global.location.port ? (':' + global.location.port) : '');
    };

    try {
      Object.defineProperty(global.location, 'origin', {
        get: getOrigin,
        enumerable: true
      });
    } catch (e) {
      setInterval(function() {
        global.location.origin = getOrigin();
      }, 100);
    }
  }

})(
  (typeof commonjsGlobal !== 'undefined') ? commonjsGlobal
    : ((typeof window !== 'undefined') ? window
    : ((typeof self !== 'undefined') ? self : commonjsGlobal))
);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

/**
 * The set of possible message types.
 */
var MESSAGE_TYPE;
(function (MESSAGE_TYPE) {
    MESSAGE_TYPE["SUBSCRIBE"] = "subscribe";
    MESSAGE_TYPE["EMIT"] = "emit";
    MESSAGE_TYPE["REQUEST"] = "request";
    MESSAGE_TYPE["RESOLVE"] = "resolve";
    MESSAGE_TYPE["REJECT"] = "reject";
})(MESSAGE_TYPE || (MESSAGE_TYPE = {}));
/**
 * The set of internally used event triggers that can be bound to.
 */
var MC_EVENTS;
(function (MC_EVENTS) {
    MC_EVENTS["HANDSHAKE"] = "mc-handshake";
    MC_EVENTS["CONNECTED"] = "mc-connected";
    MC_EVENTS["DISCONNECTED"] = "mc-disconnected";
    MC_EVENTS["CONNECTION_TIMEOUT"] = "mc-connection-timeout";
})(MC_EVENTS || (MC_EVENTS = {}));
/**
 * Connection Base Class.
 *
 * It is used to provide the shared functionality of [[ServerConnection]] and [[ClientConnection]]
 *
 */
var Connection = /** @class */ (function () {
    /**
     * Creates a Connection instance.
     * @param options Connection configuration options
     * @param options.timeout Default request timeout (ms). This will trigger a reject on a any request that takes longer than this value. 200ms by default.
     * @param options.connectionTimeout Connection timeout (ms). This will trigger the CONNECTION_TIMEOUT if a connection hasn't been established by this time.
     * @param options.debug Enabling uses console.log to output what MC is doing behind the scenes. Used for debugging. Disabled by default.
     * @param options.onload Uses the onload event of an iframe to trigger the process for creating a connection. If set to false the connection process needs to be triggered manually. Note a connection will only work if the child frame has loaded. Enabled by default.
     * @param options.targetOrigin Limits the iframe to send messages to only the specified origins. '*' by Default.
     * @param options.clientInitiates Awaits an postMessage (init) trigger from the child before it sets up and sends the MessageChannel port to the child. false by Default.
     */
    function Connection(options) {
        if (options === void 0) { options = {}; }
        /**
         * Indicates if a connection has been established
         */
        this.connected = false;
        this.backlog = [];
        this.promises = {};
        this.emitters = {};
        this.connectionStep = '';
        this.defaultOptions = {
            window: window,
            connectionTimeout: 2000,
            timeout: 200,
            debug: false,
            onload: true,
            clientInitiates: false,
            targetOrigin: '*'
        };
        this.options = __assign({}, this.defaultOptions, options);
    }
    /**
     * This method will emit an event to its counterpart.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @return Returns Connection instance.
     */
    Connection.prototype.emit = function (event, payload) {
        this.message({
            type: MESSAGE_TYPE.EMIT,
            event: event,
            payload: payload
        });
        return this;
    };
    /**
     * Bind a callback to an event.
     * @param event The name of the event to listen for.
     * @param callback The function to call when the event is fired.
     * @return Returns Connection instance.
     */
    Connection.prototype.on = function (event, callback) {
        if (this.emitters[event] && Array.isArray(this.emitters[event])) {
            this.emitters[event].push(callback);
        }
        else {
            this.emitters[event] = [callback];
        }
        return this;
    };
    /**
     * Make a request of the counterpart. It will automatically reject the promise if the timeout time is exceeded.
     * @param event The name of the event to emit
     * @param payload Payload to be sent with the request
     * @param options
     * @param options.timeout Override for the default promise timeout, can be an interger or false
     * @returns A promise that can resolve with any payload
     */
    Connection.prototype.request = function (event, payload, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return new Promise(function (resolve, reject) {
            var uuid = _this.uuidv4();
            var timeout = _this.getRequestTimeout(options.timeout);
            var ct;
            if (timeout !== false && typeof timeout === 'number') {
                ct = window.setTimeout(function () { return reject('timeout'); }, timeout);
            }
            _this.promises[uuid] = {
                resolve: function (resolvedData) {
                    resolve(resolvedData);
                    if (ct) {
                        clearTimeout(ct);
                    }
                },
                reject: function (error) {
                    reject(error);
                    if (ct) {
                        clearTimeout(ct);
                    }
                }
            };
            _this.message({
                type: MESSAGE_TYPE.REQUEST,
                event: event,
                id: uuid,
                payload: payload
            });
        });
    };
    /**
     * Close the port being used to communicate. It will prevent any further messages being sent or received.
     */
    Connection.prototype.close = function () {
        if (this.connected) {
            this.port.close();
            this.connected = false;
        }
        if (this.messageListener) {
            this.options.window.removeEventListener('message', this.messageListener, false);
        }
    };
    Connection.prototype.setConnectionTimeout = function () {
        var _this = this;
        clearTimeout(this.connectionTimeout);
        if (this.options.connectionTimeout !== false) {
            this.connectionTimeout = window.setTimeout(function () {
                if (_this.messageListener) {
                    _this.options.window.removeEventListener('message', _this.messageListener, false);
                }
                _this.handleMessage({
                    type: MESSAGE_TYPE.EMIT,
                    event: MC_EVENTS.CONNECTION_TIMEOUT,
                    payload: { message: 'Connection timed out while ' + _this.connectionStep }
                });
            }, Number(this.options.connectionTimeout));
        }
    };
    Connection.prototype.uuidv4 = function () {
        var crypt = window.crypto || window.msCrypto;
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function (c) {
            return (c ^ (crypt.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16);
        });
    };
    Connection.prototype.clearConnectionTimeout = function () {
        clearTimeout(this.connectionTimeout);
    };
    Connection.prototype.initPortEvents = function () {
        var _this = this;
        this.port.onmessage = function (message) {
            _this.handleMessage(message.data);
        };
        this.port.onmessageerror = function (error) {
            _this.handleError(error);
        };
    };
    Connection.prototype.finishInit = function () {
        this.connected = true;
        this.clearConnectionTimeout();
        if (this.options.debug) {
            console.log("Finished connection on " + (this.isClient() ? 'client' : 'server'));
        }
        this.emit(MC_EVENTS.CONNECTED);
        this.completeBacklog();
    };
    Connection.prototype.completeBacklog = function () {
        var _this = this;
        this.backlog.forEach(function (message) {
            _this.portMessage(message);
        });
        this.backlog = [];
    };
    Connection.prototype.handleError = function (error) {
        if (this.options.debug) {
            console.error(error);
        }
    };
    Connection.prototype.handleMessage = function (message) {
        var _this = this;
        if (this.options.debug) {
            console.log("handle by " + (this.isClient() ? 'client' : 'server') + " - [" + message.type + "] \"" + message.event + "\", payload: ", message.payload);
        }
        switch (message.type) {
            case MESSAGE_TYPE.EMIT:
                if (!this.emitters[message.event] || !Array.isArray(this.emitters[message.event])) {
                    return;
                }
                this.emitters[message.event].forEach(function (cb) { return cb(message.payload); });
                break;
            case MESSAGE_TYPE.REQUEST:
                if (!this.emitters[message.event] || !Array.isArray(this.emitters[message.event])) {
                    return;
                }
                this.emitters[message.event].forEach(function (cb) {
                    return cb(message.payload, function (payload) {
                        _this.message({
                            id: message.id,
                            type: MESSAGE_TYPE.RESOLVE,
                            event: message.event,
                            payload: payload
                        });
                    }, function (payload) {
                        _this.message({
                            id: message.id,
                            type: MESSAGE_TYPE.REJECT,
                            event: message.event,
                            payload: payload
                        });
                    });
                });
                break;
            case MESSAGE_TYPE.RESOLVE:
                if (!this.promises[message.id]) {
                    return;
                }
                this.promises[message.id].resolve(message.payload);
                delete this.promises[message.id];
                break;
            case MESSAGE_TYPE.REJECT:
                if (!this.promises[message.id]) {
                    return;
                }
                this.promises[message.id].reject(message.payload);
                delete this.promises[message.id];
                break;
        }
    };
    Connection.prototype.getRequestTimeout = function (timeout) {
        if (typeof timeout === 'number' && timeout >= 0) {
            return timeout;
        }
        else if (typeof timeout === 'number') {
            return 0;
        }
        else if (timeout === true) {
            return this.options.timeout;
        }
        else if (timeout === false) {
            return false;
        }
        else {
            return this.options.timeout;
        }
    };
    Connection.prototype.isClient = function () {
        return false;
    };
    Connection.prototype.message = function (message) {
        var force = false;
        if (message.event === MC_EVENTS.HANDSHAKE ||
            message.event === MC_EVENTS.CONNECTED ||
            message.event === MC_EVENTS.DISCONNECTED) {
            force = true;
        }
        if (!this.connected && !force) {
            this.backlog.push(message);
        }
        else if (this.port) {
            this.portMessage(message);
        }
    };
    Connection.prototype.portMessage = function (message) {
        if (this.options.debug) {
            console.log("send from " + (this.isClient() ? 'client' : 'server') + " - [" + message.type + "] \"" + message.event + "\", payload: ", message.payload);
        }
        this.port.postMessage(message);
    };
    return Connection;
}());

var CONNECTION_STEPS;
(function (CONNECTION_STEPS) {
    CONNECTION_STEPS["CONNECTION"] = "waiting for connection.";
    CONNECTION_STEPS["IFRAME_LOADING"] = "waiting for iframe to load.";
    CONNECTION_STEPS["INITIATION_FROM_CLIENT"] = "waiting for initiation from client.";
})(CONNECTION_STEPS || (CONNECTION_STEPS = {}));
/**
 * The parent side of the connection.
 */
var ServerConnection = /** @class */ (function (_super) {
    __extends(ServerConnection, _super);
    /**
     *
     * @param frame The iframe target to setup the connection on.
     * @param options Connection configuration options.
     * @param options.timeout Default request timeout (ms). This will trigger a reject on a any request that takes longer than this value. 200ms by default.
     * @param options.connectionTimeout Connection timeout (ms). This will trigger the CONNECTION_TIMEOUT if a connection hasn't been established by this time.
     * @param options.debug Enabling uses console.log to output what MC is doing behind the scenes. Used for debugging. Disabled by default.
     * @param options.onload Uses the onload event of an iframe to trigger the process for creating a connection. If set to false the connection process needs to be triggered manually. Note a connection will only work if the child frame has loaded. Enabled by default.
     * @param options.targetOrigin Limits the iframe to send messages to only the specified origins. '*' by Default.
     * @param options.clientInitiates Awaits an postMessage (init) trigger from the child before it sets up and sends the MessageChannel port to the child. false by Default.
     */
    function ServerConnection(frame, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, options) || this;
        _this.frame = frame;
        _this.connectionStep = CONNECTION_STEPS.CONNECTION;
        if (_this.options.onload) {
            _this.setupLoadInit();
        }
        if (_this.options.clientInitiates) {
            _this.setupClientInit();
        }
        _this.setConnectionTimeout();
        _this.on(MC_EVENTS.DISCONNECTED, function () { return _this.close(); });
        return _this;
    }
    ServerConnection.prototype.clientInitiation = function (e) {
        if (e.data === this.id) {
            this.connectionStep = CONNECTION_STEPS.CONNECTION;
            this.setConnectionTimeout();
            this.options.window.removeEventListener('message', this.messageListener, false);
            if (this.options.debug) {
                console.log('Server: Client triggered initiation');
            }
            this.init();
        }
    };
    ServerConnection.prototype.setupLoadInit = function () {
        var _this = this;
        this.connectionStep = CONNECTION_STEPS.IFRAME_LOADING;
        this.frame.addEventListener('load', function () {
            _this.connectionStep = _this.options.clientInitiates
                ? CONNECTION_STEPS.INITIATION_FROM_CLIENT
                : CONNECTION_STEPS.CONNECTION;
            _this.setConnectionTimeout();
            _this.init();
        });
    };
    ServerConnection.prototype.setupClientInit = function () {
        var _this = this;
        this.connectionStep = CONNECTION_STEPS.INITIATION_FROM_CLIENT;
        this.id = this.uuidv4();
        var url = new URL(this.frame.src);
        url.searchParams.set('mc-name', this.id);
        this.frame.src = url.toString();
        this.messageListener = function (e) { return _this.clientInitiation(e); };
        this.options.window.addEventListener('message', this.messageListener);
    };
    /**
     * Used to trigger the initiation of a connection manually. To be used if the onload, and clientInitiates options are disabled.
     */
    ServerConnection.prototype.init = function () {
        if (!this.frame.contentWindow || !this.frame.src || this.connected) {
            return false;
        }
        this.setupChannel();
        this.initPortEvents();
        this.listenForHandshake();
        this.sendPortToClient(this.frame.contentWindow);
    };
    ServerConnection.prototype.sendPortToClient = function (client) {
        client.postMessage(null, this.options.targetOrigin ? this.options.targetOrigin : '*', [
            this.channel.port2
        ]);
    };
    ServerConnection.prototype.listenForHandshake = function () {
        var _this = this;
        this.on(MC_EVENTS.HANDSHAKE, function (payload, resolve) {
            resolve(payload);
            _this.finishInit();
        });
    };
    ServerConnection.prototype.setupChannel = function () {
        this.channel = new MessageChannel();
        this.port = this.channel.port1;
    };
    return ServerConnection;
}(Connection));

var CONNECTION_STEPS$1;
(function (CONNECTION_STEPS) {
    CONNECTION_STEPS["CONNECTION"] = "waiting for connection.";
    CONNECTION_STEPS["HANDSHAKE"] = "waiting for handshake.";
})(CONNECTION_STEPS$1 || (CONNECTION_STEPS$1 = {}));
/**
 * The child side of a connection.
 */
var ClientConnection = /** @class */ (function (_super) {
    __extends(ClientConnection, _super);
    function ClientConnection(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, options) || this;
        _this.messageListener = function (e) { return _this.messageHandler(e); };
        _this.options.window.addEventListener('message', _this.messageListener);
        if (_this.options.connectionTimeout !== false) {
            _this.connectionStep = CONNECTION_STEPS$1.CONNECTION;
            _this.setConnectionTimeout();
        }
        return _this;
    }
    ClientConnection.prototype.init = function () {
        var url = new URL(this.options.window.location.toString());
        this.id = url.searchParams.get('mc-name');
        if (this.options.debug) {
            console.log('Client: sent postMessage value:', this.id);
        }
        this.options.window.parent.postMessage(this.id, this.options.targetOrigin);
    };
    ClientConnection.prototype.messageHandler = function (e) {
        if (e.ports[0]) {
            this.port = e.ports[0];
            this.initPortEvents();
            this.listenForHandshake();
            this.options.window.removeEventListener('message', this.messageListener);
        }
    };
    ClientConnection.prototype.listenForHandshake = function () {
        var _this = this;
        if (this.options.connectionTimeout !== false) {
            this.connectionStep = CONNECTION_STEPS$1.HANDSHAKE;
            this.setConnectionTimeout();
        }
        this.request(MC_EVENTS.HANDSHAKE, null, { timeout: false })
            .then(function () {
            _this.addBeforeUnloadEvent();
            _this.finishInit();
        })
            .catch(function (e) {
            _this.handleError(e);
        });
    };
    ClientConnection.prototype.addBeforeUnloadEvent = function () {
        var _this = this;
        this.options.window.addEventListener('beforeunload', function (event) {
            _this.emit(MC_EVENTS.DISCONNECTED);
            _this.close();
        });
    };
    ClientConnection.prototype.isClient = function () {
        return true;
    };
    return ClientConnection;
}(Connection));

var Operator = /** @class */ (function () {
    function Operator() {
        this.connections = [];
    }
    /**
     * Connect method will create and return a [[Connection]] instance.
     * The connection will be placed under the management of the Operator until [[close]] is called.
     * @param frame  Used for specifying an iframe for a [[ServerConnection]], if not provided it will create a [[ClientConnection]]
     * @param options  Optional param for overriding the default options of type [[Options]]
     * @returns Either a [[ServerConnection]] or [[ClientConnection]]
     */
    Operator.prototype.connect = function (frame, options) {
        if (options === void 0) { options = {}; }
        var connection;
        if (frame) {
            connection = new ServerConnection(frame, options);
            this.connections.push(connection);
        }
        else {
            connection = new ClientConnection(options);
        }
        return connection;
    };
    /**
     * This method will close the port used by the connection and remove it from the list of managed connections.
     * This will prevent group emit or group requests from being triggered on the connection.
     * @param connection
     * @return Returns Operator instance
     */
    Operator.prototype.close = function (connection) {
        this.connections = this.connections.filter(function (c) { return c !== connection; });
        connection.close();
        return this;
    };
    /**
     * This method will emit an event on all the managed connections.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @return Returns Operator instance.
     */
    Operator.prototype.emit = function (event, payload) {
        this.connections.forEach(function (connection) {
            connection.emit(event, payload);
        });
        return this;
    };
    /**
     * This method will make a request on all the managed connections.
     * It returns a promise and will resolve or reject on the first connection to make a response.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @param timeout Value to override connection option, promise will reject after this time elapses
     * @return A promise which can contain any payload
     */
    Operator.prototype.requestRace = function (event, payload, options) {
        return Promise.race(this.request(event, payload, options));
    };
    /**
     * This method will make a request on all the managed connections.
     * It returns a promise and will resolve or reject after all the connections's promises have successfully fulfilled or after a single error is thrown.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @param timeout Value to override connection option, promise will reject after this time elapses
     * @return A promise which can contain any payload
     */
    Operator.prototype.requestAll = function (event, payload, options) {
        return Promise.all(this.request(event, payload, options));
    };
    /**
     * This method will make a request on all the managed connections.
     * It returns an array containing all the promises it is then up to you manage their completion.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @param timeout Value to override connection option, promise will reject after this time elapses
     * @return An array of promises which can contain any payload
     */
    Operator.prototype.request = function (event, payload, options) {
        var promiseArray = [];
        this.connections.forEach(function (connection) {
            promiseArray.push(connection.request(event, payload, options));
        });
        return promiseArray;
    };
    return Operator;
}());

export { Operator, MESSAGE_TYPE, MC_EVENTS, Connection, ClientConnection, ServerConnection };
//# sourceMappingURL=message-event-channel.esm.js.map
