import { ConnectionOptions, Connection, RequestOptions } from './Connection';
export declare class Operator {
    private connections;
    /**
     * Connect method will create and return a [[Connection]] instance.
     * The connection will be placed under the management of the Operator until [[close]] is called.
     * @param frame  Used for specifying an iframe for a [[ServerConnection]], if not provided it will create a [[ClientConnection]]
     * @param options  Optional param for overriding the default options of type [[Options]]
     * @returns Either a [[ServerConnection]] or [[ClientConnection]]
     */
    connect(frame?: HTMLIFrameElement, options?: ConnectionOptions): Connection;
    /**
     * This method will close the port used by the connection and remove it from the list of managed connections.
     * This will prevent group emit or group requests from being triggered on the connection.
     * @param connection
     * @return Returns Operator instance
     */
    close(connection: Connection): Operator;
    /**
     * This method will emit an event on all the managed connections.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @return Returns Operator instance.
     */
    emit(event: string, payload?: any): Operator;
    /**
     * This method will make a request on all the managed connections.
     * It returns a promise and will resolve or reject on the first connection to make a response.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @param timeout Value to override connection option, promise will reject after this time elapses
     * @return A promise which can contain any payload
     */
    requestRace<T = any>(event: string, payload?: any, options?: RequestOptions): Promise<T>;
    /**
     * This method will make a request on all the managed connections.
     * It returns a promise and will resolve or reject after all the connections's promises have successfully fulfilled or after a single error is thrown.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @param timeout Value to override connection option, promise will reject after this time elapses
     * @return A promise which can contain any payload
     */
    requestAll<T = any>(event: string, payload?: any, options?: RequestOptions): Promise<Array<T>>;
    /**
     * This method will make a request on all the managed connections.
     * It returns an array containing all the promises it is then up to you manage their completion.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @param timeout Value to override connection option, promise will reject after this time elapses
     * @return An array of promises which can contain any payload
     */
    request<T = any>(event: string, payload?: any, options?: RequestOptions): Array<Promise<T>>;
}
