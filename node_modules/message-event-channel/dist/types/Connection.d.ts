export interface Promises {
    [key: string]: MPromise;
}
export interface MPromise {
    resolve: Function;
    reject: Function;
}
export interface Emits {
    [key: string]: Function[];
}
export interface EmitMessage {
    type: MESSAGE_TYPE.EMIT;
    event: string;
    payload?: any;
}
export interface RequestMessage {
    type: MESSAGE_TYPE.REQUEST;
    id: string;
    event: string;
    payload?: any;
}
export interface ResolveMessage {
    type: MESSAGE_TYPE.RESOLVE;
    id: string;
    event: string;
    payload: any;
}
export interface RejectMessage {
    type: MESSAGE_TYPE.REJECT;
    id: string;
    event: string;
    payload: any;
}
/**
 * Options for the connection.
 */
export interface ConnectionOptions {
    window?: Window;
    timeout?: number;
    connectionTimeout?: number;
    debug?: boolean;
    onload?: boolean;
    clientInitiates?: boolean;
    targetOrigin?: string;
}
export interface RequestOptions {
    timeout?: number | boolean;
}
export interface ConnectionSettings {
    window: Window;
    timeout: number | boolean;
    connectionTimeout: number | boolean;
    debug: boolean;
    onload: boolean;
    clientInitiates: boolean;
    targetOrigin: string;
}
declare type Message = ResolveMessage | RejectMessage | EmitMessage | RequestMessage;
declare global {
    interface Window {
        msCrypto: Crypto;
    }
}
/**
 * The set of possible message types.
 */
export declare enum MESSAGE_TYPE {
    SUBSCRIBE = "subscribe",
    EMIT = "emit",
    REQUEST = "request",
    RESOLVE = "resolve",
    REJECT = "reject"
}
/**
 * The set of internally used event triggers that can be bound to.
 */
export declare enum MC_EVENTS {
    HANDSHAKE = "mc-handshake",
    CONNECTED = "mc-connected",
    DISCONNECTED = "mc-disconnected",
    CONNECTION_TIMEOUT = "mc-connection-timeout"
}
/**
 * Connection Base Class.
 *
 * It is used to provide the shared functionality of [[ServerConnection]] and [[ClientConnection]]
 *
 */
export declare class Connection {
    /**
     * Indicates if a connection has been established
     */
    connected: boolean;
    id: string | null;
    protected port: MessagePort;
    private backlog;
    protected promises: Promises;
    private emitters;
    protected options: ConnectionSettings;
    protected connectionTimeout: number;
    protected connectionStep: string;
    protected messageListener: any;
    protected readonly defaultOptions: ConnectionSettings;
    /**
     * Creates a Connection instance.
     * @param options Connection configuration options
     * @param options.timeout Default request timeout (ms). This will trigger a reject on a any request that takes longer than this value. 200ms by default.
     * @param options.connectionTimeout Connection timeout (ms). This will trigger the CONNECTION_TIMEOUT if a connection hasn't been established by this time.
     * @param options.debug Enabling uses console.log to output what MC is doing behind the scenes. Used for debugging. Disabled by default.
     * @param options.onload Uses the onload event of an iframe to trigger the process for creating a connection. If set to false the connection process needs to be triggered manually. Note a connection will only work if the child frame has loaded. Enabled by default.
     * @param options.targetOrigin Limits the iframe to send messages to only the specified origins. '*' by Default.
     * @param options.clientInitiates Awaits an postMessage (init) trigger from the child before it sets up and sends the MessageChannel port to the child. false by Default.
     */
    constructor(options?: ConnectionOptions);
    /**
     * This method will emit an event to its counterpart.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @return Returns Connection instance.
     */
    emit(event: string, payload?: any): this;
    /**
     * Bind a callback to an event.
     * @param event The name of the event to listen for.
     * @param callback The function to call when the event is fired.
     * @return Returns Connection instance.
     */
    on(event: string, callback: Function): this;
    /**
     * Make a request of the counterpart. It will automatically reject the promise if the timeout time is exceeded.
     * @param event The name of the event to emit
     * @param payload Payload to be sent with the request
     * @param options
     * @param options.timeout Override for the default promise timeout, can be an interger or false
     * @returns A promise that can resolve with any payload
     */
    request<T = any>(event: string, payload?: any, options?: RequestOptions): Promise<T>;
    /**
     * Close the port being used to communicate. It will prevent any further messages being sent or received.
     */
    close(): void;
    protected setConnectionTimeout(): void;
    protected uuidv4(): string;
    protected clearConnectionTimeout(): void;
    protected initPortEvents(): void;
    protected finishInit(): void;
    protected completeBacklog(): void;
    protected handleError(error: any): void;
    protected handleMessage(message: Message): void;
    protected getRequestTimeout(timeout: number | boolean | undefined): number | boolean;
    protected isClient(): Boolean;
    protected message(message: Message): void;
    private portMessage;
}
export {};
