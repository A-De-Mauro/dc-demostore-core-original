"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ServerConnection_1 = require("./ServerConnection");
var ClientConnection_1 = require("./ClientConnection");
var Operator = /** @class */ (function () {
    function Operator() {
        this.connections = [];
    }
    /**
     * Connect method will create and return a [[Connection]] instance.
     * The connection will be placed under the management of the Operator until [[close]] is called.
     * @param frame  Used for specifying an iframe for a [[ServerConnection]], if not provided it will create a [[ClientConnection]]
     * @param options  Optional param for overriding the default options of type [[Options]]
     * @returns Either a [[ServerConnection]] or [[ClientConnection]]
     */
    Operator.prototype.connect = function (frame, options) {
        if (options === void 0) { options = {}; }
        var connection;
        if (frame) {
            connection = new ServerConnection_1.ServerConnection(frame, options);
            this.connections.push(connection);
        }
        else {
            connection = new ClientConnection_1.ClientConnection(options);
        }
        return connection;
    };
    /**
     * This method will close the port used by the connection and remove it from the list of managed connections.
     * This will prevent group emit or group requests from being triggered on the connection.
     * @param connection
     * @return Returns Operator instance
     */
    Operator.prototype.close = function (connection) {
        this.connections = this.connections.filter(function (c) { return c !== connection; });
        connection.close();
        return this;
    };
    /**
     * This method will emit an event on all the managed connections.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @return Returns Operator instance.
     */
    Operator.prototype.emit = function (event, payload) {
        this.connections.forEach(function (connection) {
            connection.emit(event, payload);
        });
        return this;
    };
    /**
     * This method will make a request on all the managed connections.
     * It returns a promise and will resolve or reject on the first connection to make a response.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @param timeout Value to override connection option, promise will reject after this time elapses
     * @return A promise which can contain any payload
     */
    Operator.prototype.requestRace = function (event, payload, options) {
        return Promise.race(this.request(event, payload, options));
    };
    /**
     * This method will make a request on all the managed connections.
     * It returns a promise and will resolve or reject after all the connections's promises have successfully fulfilled or after a single error is thrown.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @param timeout Value to override connection option, promise will reject after this time elapses
     * @return A promise which can contain any payload
     */
    Operator.prototype.requestAll = function (event, payload, options) {
        return Promise.all(this.request(event, payload, options));
    };
    /**
     * This method will make a request on all the managed connections.
     * It returns an array containing all the promises it is then up to you manage their completion.
     * @param event The name of the event to emit.
     * @param payload Payload to be sent with the event.
     * @param timeout Value to override connection option, promise will reject after this time elapses
     * @return An array of promises which can contain any payload
     */
    Operator.prototype.request = function (event, payload, options) {
        var promiseArray = [];
        this.connections.forEach(function (connection) {
            promiseArray.push(connection.request(event, payload, options));
        });
        return promiseArray;
    };
    return Operator;
}());
exports.Operator = Operator;
//# sourceMappingURL=Operator.js.map