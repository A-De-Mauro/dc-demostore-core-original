"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Connection_1 = require("./Connection");
var CONNECTION_STEPS;
(function (CONNECTION_STEPS) {
    CONNECTION_STEPS["CONNECTION"] = "waiting for connection.";
    CONNECTION_STEPS["IFRAME_LOADING"] = "waiting for iframe to load.";
    CONNECTION_STEPS["INITIATION_FROM_CLIENT"] = "waiting for initiation from client.";
})(CONNECTION_STEPS || (CONNECTION_STEPS = {}));
/**
 * The parent side of the connection.
 */
var ServerConnection = /** @class */ (function (_super) {
    __extends(ServerConnection, _super);
    /**
     *
     * @param frame The iframe target to setup the connection on.
     * @param options Connection configuration options.
     * @param options.timeout Default request timeout (ms). This will trigger a reject on a any request that takes longer than this value. 200ms by default.
     * @param options.connectionTimeout Connection timeout (ms). This will trigger the CONNECTION_TIMEOUT if a connection hasn't been established by this time.
     * @param options.debug Enabling uses console.log to output what MC is doing behind the scenes. Used for debugging. Disabled by default.
     * @param options.onload Uses the onload event of an iframe to trigger the process for creating a connection. If set to false the connection process needs to be triggered manually. Note a connection will only work if the child frame has loaded. Enabled by default.
     * @param options.targetOrigin Limits the iframe to send messages to only the specified origins. '*' by Default.
     * @param options.clientInitiates Awaits an postMessage (init) trigger from the child before it sets up and sends the MessageChannel port to the child. false by Default.
     */
    function ServerConnection(frame, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this, options) || this;
        _this.frame = frame;
        _this.connectionStep = CONNECTION_STEPS.CONNECTION;
        if (_this.options.onload) {
            _this.setupLoadInit();
        }
        if (_this.options.clientInitiates) {
            _this.setupClientInit();
        }
        _this.setConnectionTimeout();
        _this.on(Connection_1.MC_EVENTS.DISCONNECTED, function () { return _this.close(); });
        return _this;
    }
    ServerConnection.prototype.clientInitiation = function (e) {
        if (e.data === this.id) {
            this.connectionStep = CONNECTION_STEPS.CONNECTION;
            this.setConnectionTimeout();
            this.options.window.removeEventListener('message', this.messageListener, false);
            if (this.options.debug) {
                console.log('Server: Client triggered initiation');
            }
            this.init();
        }
    };
    ServerConnection.prototype.setupLoadInit = function () {
        var _this = this;
        this.connectionStep = CONNECTION_STEPS.IFRAME_LOADING;
        this.frame.addEventListener('load', function () {
            _this.connectionStep = _this.options.clientInitiates
                ? CONNECTION_STEPS.INITIATION_FROM_CLIENT
                : CONNECTION_STEPS.CONNECTION;
            _this.setConnectionTimeout();
            _this.init();
        });
    };
    ServerConnection.prototype.setupClientInit = function () {
        var _this = this;
        this.connectionStep = CONNECTION_STEPS.INITIATION_FROM_CLIENT;
        this.id = this.uuidv4();
        var url = new URL(this.frame.src);
        url.searchParams.set('mc-name', this.id);
        this.frame.src = url.toString();
        this.messageListener = function (e) { return _this.clientInitiation(e); };
        this.options.window.addEventListener('message', this.messageListener);
    };
    /**
     * Used to trigger the initiation of a connection manually. To be used if the onload, and clientInitiates options are disabled.
     */
    ServerConnection.prototype.init = function () {
        if (!this.frame.contentWindow || !this.frame.src || this.connected) {
            return false;
        }
        this.setupChannel();
        this.initPortEvents();
        this.listenForHandshake();
        this.sendPortToClient(this.frame.contentWindow);
    };
    ServerConnection.prototype.sendPortToClient = function (client) {
        client.postMessage(null, this.options.targetOrigin ? this.options.targetOrigin : '*', [
            this.channel.port2
        ]);
    };
    ServerConnection.prototype.listenForHandshake = function () {
        var _this = this;
        this.on(Connection_1.MC_EVENTS.HANDSHAKE, function (payload, resolve) {
            resolve(payload);
            _this.finishInit();
        });
    };
    ServerConnection.prototype.setupChannel = function () {
        this.channel = new MessageChannel();
        this.port = this.channel.port1;
    };
    return ServerConnection;
}(Connection_1.Connection));
exports.ServerConnection = ServerConnection;
//# sourceMappingURL=ServerConnection.js.map